**Homework 01 - Kristen Wright**
1.	The four perceived components of software crisis are litigation disputes,
 lack of functionality, late delivery date, or software deemed unusable.

2.	The software life cycle encompasses the entire process of the software beyond delivery, 
including postdelivery maintenance and eventual deprecation. The software development cycle does not
 follow along after the delivery of software.

3.	Perfective maintenance is a process of improving the performance of software. Essentially, after
 the release of software perfective maintenance exists in the form of performance tweaks and bug fixes to
 make the software run better and more efficiently, essentially "perfecting" it.  
Likewise adaptive maintenance is a process of adapting the software to the changing environment. After
 the release of software it will be updated to not just improve on existing functions but to change functionality to
 accomodate for change. This makes it adaptive--it will "adapt" to the user's needs.

4.	Software is in a physical sense static; hardware, being a physical piece of material, can indeed
 wear down and become obsolete with time. Software on the other hand has a relevance that relies entirely
 on how well the programmer maintains it. That makes it a concept of comparing the physical to the
 abstract; software, being an abstract concept formed by the proper use of hardware, does not physically
 "age" with time and therefore every update to a software can be considered an improvement, not a degradation.

5.	The argument is always that by proper, thorough testing one may eradicate bugs before they reach
 the public, and so the lack of thorough testing is what leads to the detecting of bugs lateron after delivery.
 These bugs can cost a company in customers, resources, time (which could be spent building something else),
 and even legal fees. These are all things that would be saved by addressing the issues during development.
 However for the most part software undergoes its heaviest challenges when its customers, who approach it
 with different strategies on different hardware systems, use it thoroughly. Also as updates roll out and
a software's complexity grows, the longer a fault goes unchecked and continues to produce issues in the background, the pricier it will be to correct it.

6.	This tells you that planning, testing, and documentation should be done throughout. This is to 
both keep your project on track and to keep your team up to date, as well as to consistently address 
problems as they arise.

7.	It is first important to note that structured programming and object oriented programming are not
 the same thing. Furthermore, structured programming is essential to promote efficiency in a system;
 a properly-used do-while loop may be very well more valuable than a recursive object. Object oriented 
programming after all relies very much on memory management and the skill level of a programmer to 
maintain it. Programming structures, on the other hand, exist both inside and outside an object.
 They are essentially both necessary to create a proper system.

8.	By code of ethics, a software developer must first respect the wishes of the client/employer. This means
 that the client, technically, gets first say. However, the developer must also take into account the fact 
that the _user_ is the one who will be accessing the product. This means it is important to do what the user
 needs done for the system. That is where a balance has to come into play. The devloper has to listen to the client
 _and_ the user. Options from both must be weighed to ensure a software is both ethical and usable.

9.	Software developers are in many ways the eternal student; even the environments and languages we
 use are constantly rolling out changes and updates. It is important to always look into these updates and be
 aware of the changes coming in the next update cycle. For instance, Swift programmers are seeing a rapidly
 changing language where things we used even one or two years ago are now far deprecated and unusable. 
This means Swift programmers must constantly monitor new and upcoming changes, and challenge themselves 
to explore these changes so that they may utilize them in the best way possible.

10.	Mr. Raymond emphasizes in his text to "put behind the cathedral and embrace the bazaar." He makes
 an argument that open source software is necessary for the creation of good, effective software. He makes
 many good points about how the "bazaar" of open source is helpful to not only find and address bug issues but
 also to create adaptive solutions, with a better communication base between yourself and the user. While I
 don't necessarily agree with every point he makes about why open source software should replace the traditiona
 "cathedral" of development, he makes a strong argument on how open source software promotes better programming
 and better software.