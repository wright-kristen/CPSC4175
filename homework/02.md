#Kristen Wright - Homework 02#

1.	The first step in creating a piece of software is the "requirements" step. Or, the stage in which 
the problem is addressed and the expectations of the solution are proposed in the software requirements.

2.	There are some ways this happens. In some senses it's about intuition; requirements are the
 visualization of what the client needs. However, the client only gives you what they _want_. Often
 it is up to the understanding of the software engineer to provide what the client actually _needs_.

3.	By definition a specialist is someone who has mastery in a very small, very specific field. Specialization 
is not abstract. A generalist, on the other hand, would be someone with an abstract view of a larger, 
more complex system. This is what a software engineer does in building computer software; a computer is
 from a mathematical standpoint an abstraction on top of abstractions, which means unlike a neurosurgeon
who must have a full and complete understanding of the particular neurological issues he specializes in, 
a software engineer must be able to wholly express an abstract problem via software.

4.	One way to determine requirements is via a structured interview. However, in constructing the interview
 questions the interviewer must have a full grasp of the application domain and the problem to address. Another
 solution, then, is an unstructured interview - but the interviewee may not have a full grasp of the problem
 and some issues may be left out of the equation. Either way some things may be overlooked. Another solution is
 the questionairre - which, like interviews, may lead to some overlooked issues. Some software developers look at
company issued forms to determine the requirements, but then the scope is narrowed only to what is found 
on paper, and so the accuracy of the requirements depends on the discretion of the developer and their attention
 to detail. Lastly, one can observe via video or physically where to find the problem - which also requires
 the careful attention of the developer.  Overall as each method has their strengths it is necessary to examine the
 processes to use on a case by case basis.

5.	Requirements change as a software undergoes development and testing. It is not always possible or feasible
 to complete all of the original requirements. It is also possible that new requirements emerge. Therefore 
it is impossible to keep requirements static - because they have to adapt to the needs of the client and the necessary 
steps to create software.

6.	I like to think of functional requirements in terms of a car. Functional requirements would be the motor, 
the freely turning wheel axle, the mechanism. Nonfunctional requirements would include the color of the dash, the
 way the dome light comes on when you open the door. Software is the same way. Functional requirements must 
_complete a task_ while nonfunctional requirements enhance the user's enjoyment of the task, such as changing the
 color of the text to something easy to look at.

7.	Top-down analysis is an analysis system where you start from the "top", or the full abstract picture of the 
problem, and then work your way "down" to the details. In the case study, using top-down analysis the developer would have
 first looked at the big picture, or in this case the full concept of the investment system. Rather, the case study first 
examines the issue from an applicant's basis, the very bottom level of the heirarchy, then builds from there. In a sense it is
 like working backwards from top-down.

8.	As someone who spends a lot of time studying HCI I would like to first say that prototyping is _incredibly_ important
 in creating a user-friendly software. However, old fashioned developers may see it as focusing on the nonfunctional requirements 
before focusing on the functional ones. This, to them, would be completely backwards and the wrong approach to developing software.  
The point of prototyping, especially rapid prototyping, is to ensure the functional requirements _fit_ with the nonfunctional requirements.
 After all, a user has to _enjoy_ using the software if you intend to persuade them to use it.

9.	There is not enough information to address this question. How is Team Two changing their requirements? Why hasn't Team One made many changes?
 Who is addressing testing issues most thoroughly? I can't say either is the better team unless I know why or _how_ frequently they're changing their
 requirements, or how they're addressing problems. Team Two may just be making additional features that will complicate issues. Team One may not be addressing
 their problems properly.

10.	Requirements are the backbones of software. In order to make it functional requirements must be met. However if Intern Joe 
writes the requirements without properly addressing the problem - such as writing requirements for a connectivity software with no 
security feature - then there will be underlying issues even if all of the requirements are met. Also, if the requirements contradict each
 other, there will be problems. Essentially, to create a software that _works_ we have to create and maintain good, concise requirements
 that effectively address the problem.